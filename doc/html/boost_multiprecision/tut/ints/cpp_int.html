<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>cpp_int</title>
<link rel="stylesheet" href="http://www.boost.org/doc/libs/release/doc/src/boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../../../index.html" title="Chapter&#160;1.&#160;Boost.Multiprecision">
<link rel="up" href="../ints.html" title="Integer Types">
<link rel="prev" href="../ints.html" title="Integer Types">
<link rel="next" href="gmp_int.html" title="gmp_int">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../ints.html"><img src="../../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../ints.html"><img src="../../../images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../images/home.png" alt="Home"></a><a accesskey="n" href="gmp_int.html"><img src="../../../images/next.png" alt="Next"></a>
</div>
<div class="section boost_multiprecision_tut_ints_cpp_int">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_multiprecision.tut.ints.cpp_int"></a><a class="link" href="cpp_int.html" title="cpp_int">cpp_int</a>
</h4></div></div></div>
<p>
          <code class="computeroutput"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multiprecision</span><span class="special">/</span><span class="identifier">cpp_int</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span></code>
        </p>
<pre class="programlisting"><span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">{</span> <span class="keyword">namespace</span> <span class="identifier">multiprecision</span><span class="special">{</span>

<span class="keyword">typedef</span> <span class="identifier">unspecified</span><span class="special">-</span><span class="identifier">type</span> <span class="identifier">limb_type</span><span class="special">;</span>

<span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">unsigned</span> <span class="identifier">MinDigits</span> <span class="special">=</span> <span class="number">0</span><span class="special">,</span> <span class="keyword">bool</span> <span class="identifier">Signed</span> <span class="special">=</span> <span class="keyword">true</span><span class="special">,</span> <span class="keyword">class</span> <span class="identifier">Allocator</span> <span class="special">=</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">limb_type</span><span class="special">&gt;</span> <span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">cpp_int_backend</span><span class="special">;</span>

<span class="keyword">typedef</span> <span class="identifier">mp_number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span>           <span class="identifier">cpp_int</span><span class="special">;</span>    <span class="comment">// arbitrary precision integer</span>
<span class="keyword">typedef</span> <span class="identifier">rational_adapter</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;&gt;</span> <span class="special">&gt;</span>    <span class="identifier">cpp_rational_backend</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">mp_number</span><span class="special">&lt;</span><span class="identifier">cpp_rational_backend</span><span class="special">&gt;</span>         <span class="identifier">cpp_rational</span><span class="special">;</span> <span class="comment">// arbitrary precision rational number</span>

<span class="comment">// Fixed precision unsigned types:</span>
<span class="keyword">typedef</span> <span class="identifier">mp_number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;</span><span class="number">128</span><span class="special">,</span> <span class="keyword">false</span><span class="special">,</span> <span class="keyword">void</span><span class="special">&gt;,</span> <span class="keyword">false</span><span class="special">&gt;</span>   <span class="identifier">mp_uint128_t</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">mp_number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;</span><span class="number">256</span><span class="special">,</span> <span class="keyword">false</span><span class="special">,</span> <span class="keyword">void</span><span class="special">&gt;,</span> <span class="keyword">false</span><span class="special">&gt;</span>   <span class="identifier">mp_uint256_t</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">mp_number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;</span><span class="number">512</span><span class="special">,</span> <span class="keyword">false</span><span class="special">,</span> <span class="keyword">void</span><span class="special">&gt;,</span> <span class="keyword">false</span><span class="special">&gt;</span>   <span class="identifier">mp_uint512_t</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">mp_number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;</span><span class="number">1024</span><span class="special">,</span> <span class="keyword">false</span><span class="special">,</span> <span class="keyword">void</span><span class="special">&gt;,</span> <span class="keyword">false</span><span class="special">&gt;</span>  <span class="identifier">mp_uint1024_t</span><span class="special">;</span>

<span class="comment">// Fixed precision signed types:</span>
<span class="keyword">typedef</span> <span class="identifier">mp_number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;</span><span class="number">128</span><span class="special">,</span> <span class="keyword">true</span><span class="special">,</span> <span class="keyword">void</span><span class="special">&gt;,</span> <span class="keyword">false</span><span class="special">&gt;</span>    <span class="identifier">mp_int128_t</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">mp_number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;</span><span class="number">256</span><span class="special">,</span> <span class="keyword">true</span><span class="special">,</span> <span class="keyword">void</span><span class="special">&gt;,</span> <span class="keyword">false</span><span class="special">&gt;</span>    <span class="identifier">mp_int256_t</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">mp_number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;</span><span class="number">512</span><span class="special">,</span> <span class="keyword">true</span><span class="special">,</span> <span class="keyword">void</span><span class="special">&gt;,</span> <span class="keyword">false</span><span class="special">&gt;</span>    <span class="identifier">mp_int512_t</span><span class="special">;</span>
<span class="keyword">typedef</span> <span class="identifier">mp_number</span><span class="special">&lt;</span><span class="identifier">cpp_int_backend</span><span class="special">&lt;</span><span class="number">1024</span><span class="special">,</span> <span class="keyword">true</span><span class="special">,</span> <span class="keyword">void</span><span class="special">&gt;,</span> <span class="keyword">false</span><span class="special">&gt;</span>   <span class="identifier">mp_int1024_t</span><span class="special">;</span>

<span class="special">}}</span> <span class="comment">// namespaces</span>
</pre>
<p>
          The <code class="computeroutput"><span class="identifier">cpp_int_backend</span></code> type
          is used via one of the typedefs <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">cpp_int</span></code>,
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">mp_uint128_t</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">mp_uint256_t</span></code>,
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">mp_uint512_t</span></code>, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">mp_int128_t</span></code>,
          <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">mp_int256_t</span></code> or <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">::</span><span class="identifier">mp_int512_t</span></code>.
        </p>
<p>
          This back-end is the "Swiss Army Knife" of integer types as it
          can represent both fixed and <a href="http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic" target="_top">arbitrary
          precision</a> integer types, and both signed and unsigned types. There
          are three template arguments:
        </p>
<div class="variablelist">
<p class="title"><b></b></p>
<dl>
<dt><span class="term">MinBits</span></dt>
<dd><p>
                Determines the number of Bits to store directly within the object
                before resorting to dynamic memory allocation. When zero, this field
                is determined automatically based on how many bits can be stored
                in union with the dynamic storage header: setting a larger value
                may improve performance as larger integer values will be stored internally
                before memory allocation is required. When the Allocator parameter
                is type <code class="computeroutput"><span class="keyword">void</span></code>, then this
                field determines the total number of bits in the resulting fixed
                precision type.
              </p></dd>
<dt><span class="term">Signed</span></dt>
<dd><p>
                Determines whether the resulting type is signed or not. Note that
                for <a href="http://en.wikipedia.org/wiki/Arbitrary-precision_arithmetic" target="_top">arbitrary
                precision</a> types (where the Allocator parameter is non-void),
                then this parameter must be <code class="computeroutput"><span class="keyword">true</span></code>.
                For fixed precision types then this type may be either <code class="computeroutput"><span class="keyword">true</span></code> (type is signed), or <code class="computeroutput"><span class="keyword">false</span></code> (type is unsigned).
              </p></dd>
<dt><span class="term">Allocator</span></dt>
<dd><p>
                The allocator to use for dynamic memory allocation, or type <code class="computeroutput"><span class="keyword">void</span></code> if this is to be a fixed precision
                type.
              </p></dd>
</dl>
</div>
<p>
          Things you should know when using this type:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              Default constructed <code class="computeroutput"><span class="identifier">cpp_int_backend</span></code>s
              have the value zero.
            </li>
<li class="listitem">
              Division by zero results in a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span></code>
              being thrown.
            </li>
<li class="listitem">
              Construction from a string that contains invalid non-numeric characters
              results in a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span></code> being thrown.
            </li>
<li class="listitem">
              Since the precision of <code class="computeroutput"><span class="identifier">cpp_int_backend</span></code>
              is necessarily limited when the allocator parameter is void, care should
              be taken to avoid numeric overflow when using this type unless you
              actually want modulo-arithmetic behavior.
            </li>
<li class="listitem">
              The type uses a sign-magnitude representation internally, so type
              <code class="computeroutput"><span class="identifier">mp_int128_t</span></code> has 128-bits
              of precision plus an extra sign bit. In this respect the behaviour
              of these types differs from built-in 2's complement types. In might
              be tempting to use a 127-bit type instead, and indeed this does work,
              but behaviour is still slightly different from a 2's complement built-in
              type as the min and max values are identical (apart from the sign),
              where as they differ by one for a true 2's complement type. That said
              it should be noted that there's no requirement for built-in types to
              be 2's complement either - it's simply that this is the most common
              format by far.
            </li>
<li class="listitem">
              Attempting to print negative values as either an Octal or Hexadecimal
              string results in a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">runtime_error</span></code>
              being thrown, this is a direct consequence of the sign-magnitude representation.
            </li>
<li class="listitem">
              The fixed precision types <code class="computeroutput"><span class="identifier">mp_</span><span class="special">[</span><span class="identifier">u</span><span class="special">]</span><span class="identifier">intXXX_t</span></code>
              have expression template support turned off - it seems to make little
              difference to the performance of these types either way - so we may
              as well have the faster compile times by turning the feature off.
            </li>
</ul></div>
<h6>
<a name="boost_multiprecision.tut.ints.cpp_int.h0"></a>
          <span><a name="boost_multiprecision.tut.ints.cpp_int.example_"></a></span><a class="link" href="cpp_int.html#boost_multiprecision.tut.ints.cpp_int.example_">Example:</a>
        </h6>
<p>
</p>
<pre class="programlisting"><span class="preprocessor">#include</span> <span class="special">&lt;</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">multiprecision</span><span class="special">/</span><span class="identifier">cpp_int</span><span class="special">.</span><span class="identifier">hpp</span><span class="special">&gt;</span>

<span class="keyword">using</span> <span class="keyword">namespace</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">multiprecision</span><span class="special">;</span>

<span class="identifier">mp_int128_t</span> <span class="identifier">v</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span>

<span class="comment">// Do some fixed precision arithmetic:</span>
<span class="keyword">for</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="number">20</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
   <span class="identifier">v</span> <span class="special">*=</span> <span class="identifier">i</span><span class="special">;</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">v</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span> <span class="comment">// prints 20!</span>

<span class="comment">// Repeat at arbitrary precision:</span>
<span class="identifier">cpp_int</span> <span class="identifier">u</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span>
<span class="keyword">for</span><span class="special">(</span><span class="keyword">unsigned</span> <span class="identifier">i</span> <span class="special">=</span> <span class="number">1</span><span class="special">;</span> <span class="identifier">i</span> <span class="special">&lt;=</span> <span class="number">100</span><span class="special">;</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
   <span class="identifier">u</span> <span class="special">*=</span> <span class="identifier">i</span><span class="special">;</span>

<span class="identifier">std</span><span class="special">::</span><span class="identifier">cout</span> <span class="special">&lt;&lt;</span> <span class="identifier">u</span> <span class="special">&lt;&lt;</span> <span class="identifier">std</span><span class="special">::</span><span class="identifier">endl</span><span class="special">;</span> <span class="comment">// prints 100!</span>
</pre>
<p>
        </p>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2002-2012 John Maddock and Christopher Kormanyos<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>)
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../ints.html"><img src="../../../images/prev.png" alt="Prev"></a><a accesskey="u" href="../ints.html"><img src="../../../images/up.png" alt="Up"></a><a accesskey="h" href="../../../index.html"><img src="../../../images/home.png" alt="Home"></a><a accesskey="n" href="gmp_int.html"><img src="../../../images/next.png" alt="Next"></a>
</div>
</body>
</html>
